"""
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/oKBKLVb21nY

Подвиг 10. Вам необходимо описывать в программе очень большие и разреженные таблицы данных (с большим числом пропусков).
Для этого предлагается объявить класс SparseTable, объекты которого создаются командой:
st = SparseTable()
В каждом объекте этого класса должны создаваться локальные публичные атрибуты:
- rows - общее число строк таблицы (начальное значение 0);
- cols - общее число столбцов таблицы (начальное значение 0).
В самом классе SparseTable должны быть объявлены методы:
- add_data(row, col, data) - добавление данных data (объект класса Cell) в таблицу по индексам row, col (целые неотрицательные числа);
- remove_data(row, col) - удаление ячейки (объект класса Cell) с индексами (row, col).
-- При удалении/добавлении новой ячейки должны автоматически пересчитываться атрибуты rows, cols объекта класса SparseTable.
Если происходит попытка удалить несуществующую ячейку, то должно генерироваться исключение:
raise IndexError('ячейка с указанными индексами не существует')
    Также с объектами класса SparseTable должны выполняться команды:
res = st[i, j] # получение данных из таблицы по индексам (i, j)
st[i, j] = value # запись новых данных по индексам (i, j)
Чтение данных возможно только для существующих ячеек. Если ячейки с указанными индексами нет, то генерировать исключение командой:
raise ValueError('данные по указанным индексам отсутствуют')
При записи новых значений их следует менять в существующей ячейке или добавлять новую, если ячейка с индексами (i, j) отсутствует в таблице.
(Не забывайте при этом пересчитывать атрибуты rows и cols).

Ячейки таблицы представляют собой объекты класса Cell, которые создаются командой:
data = Cell(value)
где value - данные ячейки (любой тип).
Хранить ячейки следует в словаре, ключами которого являются индексы (кортеж) i, j, а значениями - объекты класса Cell.


# Пример использования классов (эти строчки в программе не писать):
st = SparseTable()
st.add_data(2, 5, Cell("cell_25"))
st.add_data(0, 0, Cell("cell_00"))
st[2, 5] = 25 # изменение значения существующей ячейки
st[11, 7] = 'cell_117' # создание новой ячейки
print(st[0, 0]) # cell_00
st.remove_data(2, 5)
print(st.rows, st.cols) # 12, 8 - общее число строк и столбцов в таблице
val = st[2, 5] # ValueError
st.remove_data(12, 3) # IndexError
P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.
"""


# ваш код:
class SparseTable:
    def __init__(self):
        # В каждом объекте этого класса должны создаваться локальные публичные атрибуты:
        self.rows = 0  # общее число строк таблицы (начальное значение 0);
        self.cols = 0  # общее число столбцов таблицы (начальное значение 0).
        # Хранить ячейки следует в словаре, ключами которого являются индексы (кортеж) i, j, а значениями - объекты класса Cell.
        self.dict_obj = dict()

    # функция обновления rows/cols
    def update_r_c(self):
        self.rows = max(_[0] for _ in self.dict_obj) + 1
        self.cols = max(_[1] for _ in self.dict_obj) + 1

    # добавление данных data (объект класса Cell) в таблицу по индексам row, col (целые неотрицательные числа);
    # При добавлении новой ячейки должны автоматически пересчитываться атрибуты rows, cols объекта класса SparseTable.
    def add_data(self, row, col, data):
        """Добавление данных data (объект класса Cell) в таблицу по индексам row, col (целые неотрицательные числа)"""
        # проверка - целые неотрицательные числа
        if type(row) == int and type(col) == int and row >= 0 and col >= 0:
            self.dict_obj[(row, col)] = Cell(data)
            self.update_r_c()

    # Если происходит попытка удалить несуществующую ячейку, то должно генерироваться исключение:
    # raise IndexError('ячейка с указанными индексами не существует')
    # При удалении новой ячейки должны автоматически пересчитываться атрибуты rows, cols объекта класса SparseTable.
    def remove_data(self, row, col):
        """Удаление ячейки (объект класса Cell) с индексами (row, col)"""
        if (row, col) in self.dict_obj:
            del self.dict_obj[(row, col)]
            self.update_r_c()
        else:
            raise IndexError('ячейка с указанными индексами не существует')

    # Также с объектами класса SparseTable должны выполняться команды:
    # res = st[i, j] # получение данных из таблицы по индексам (i, j)
    # Чтение данных возможно только для существующих ячеек. Если ячейки с указанными индексами нет, то генерировать исключение командой:
    # raise ValueError('данные по указанным индексам отсутствуют')
    def __getitem__(self, item):
        """Получение данных из таблицы по индексам (i, j)"""
        x = self.dict_obj.get((item[0], item[1]), False)
        if x:
            return self.dict_obj[(item[0], item[1])].value
        else:
            raise ValueError('данные по указанным индексам отсутствуют')

    # При записи новых значений их следует менять в существующей ячейке или добавлять новую, если ячейка с индексами (i, j) отсутствует в таблице.
    # (Не забывайте при этом пересчитывать атрибуты self.rows и self.cols).
    # st[i, j] = value # запись новых данных по индексам (i, j)
    def __setitem__(self, key, value):
        # проверка - целые неотрицательные числа
        if type(key[0]) == int and type(key[1]) == int and key[0] >= 0 and key[1] >= 0:
            if key in self.dict_obj:
                self.dict_obj[(key[0], key[1])].value = value
            else:
                self.dict_obj[(key[0], key[1])] = Cell(value)
                self.update_r_c()


# Ячейки таблицы представляют собой объекты класса Cell, которые создаются командой:
# data = Cell(value)
# где value - данные ячейки (любой тип).
# Хранить ячейки следует в словаре, ключами которого являются индексы (кортеж) i, j, а значениями - объекты класса Cell.
class Cell:
    def __init__(self, value):
        self.value = value


# end ваш код

# TEST-TASK___________________________________
from test3_8.test_3_8_10 import test_10

test_10(SparseTable, Cell)

# END
