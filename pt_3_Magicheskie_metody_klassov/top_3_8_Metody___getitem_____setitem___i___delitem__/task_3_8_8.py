"""
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/Uk-cA4xC9fc

Подвиг 8. Вам нужно реализовать в программе игровое поле для игры "Крестики-нолики".
Для этого требуется объявить класс TicTacToe (крестики-нолики), объекты которого создаются командой:

Каждая клетка игрового поля представляется объектом класса Cell и создается командой:
cell = Cell()
Объекты класса Cell должны иметь следующие публичные локальные атрибуты:
is_free - True - если клетка свободна; False - в противном случае;
value - значение поля: 1 - крестик; 2 - нолик (по умолчанию 0).
Также с каждым объектом класса Cell должна работать функция:
- bool(cell) которая возвращает True, если клетка свободна (cell.is_free=True) и False в противном случае.


game = TicTacToe()
Каждый объект game должен иметь публичный атрибут:
pole - игровое поле: кортеж размером 3х3 с объектами класса Cell.

Класс TicTacToe должен иметь следующий метод:
- clear() - очистка игрового поля (все клетки заполняются нулями и переводятся в закрытое состояние);

А объекты этого класса должны иметь следующую функциональность (обращение по индексам):
game[0, 0] = 1 # установка нового значения, если поле закрыто
res = game[1, 1] # получение значения центральной ячейки поля (возвращается число)
Если указываются некорректные индексы, то должно генерироваться исключение командой:
raise IndexError('неверный индекс клетки')
Если идет попытка присвоить новое значение в открытую клетку поля, то генерировать исключение:
raise ValueError('клетка уже занята')
Также должны быть реализованы следующие полные срезы при обращении к клеткам игрового поля:
slice_1 = game[:, indx] # выбираются все элементы (кортеж) столбца с индексом indx
slice_2 = game[indx, :] # выбираются все элементы (кортеж) строки с индексом indx
Пример использования классов (эти строчки в программе не писать):

game = TicTacToe()
game.clear()
game[0, 0] = 1
game[1, 0] = 2
# формируется поле:
# 1 0 0
# 2 0 0
# 0 0 0
game[3, 2] = 2 # генерируется исключение IndexError
if game[0, 0] == 0:
    game[0, 0] = 2
v1 = game[0, :]  # 1, 0, 0
v2 = game[:, 0]  # 1, 2, 0
P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.

P.P.S. При передаче среза в магических методах __setitem__() и __getitem__() параметр индекса становится объектом класса slice. Его можно указывать непосредственно в квадратных скобках упорядоченных коллекций (списков, кортежей и т.п.).
"""


# ваш код:
class TicTacToe:
    """Игровое поле"""

    def __init__(self):
        # - игровое поле: кортеж размером 3х3 с объектами класса Cell.
        self.pole = tuple(tuple(Cell() for __ in range(3)) for _ in range(3))

    # Класс TicTacToe должен иметь следующий метод:
    # - clear() - очистка игрового поля (все клетки заполняются нулями и переводятся в закрытое состояние);
    def clear(self):
        for _ in self.pole:
            for i in _:
                i.value = 0
                i.is_free = True

    # А объекты этого класса должны иметь следующую функциональность (обращение по индексам):
    # game[0, 0] = 1 # установка нового значения, если поле закрыто
    # Если указываются некорректные индексы, то должно генерироваться исключение командой:
    # raise IndexError('неверный индекс клетки')

    def __setitem__(self, key, val):
        if 0 <= key[0] < len(self.pole[0]) and 0 <= key[1] < len(self.pole[0]):
            self.pole[key[0]][key[1]].value = val
        else:
            raise IndexError('неверный индекс клетки')

    # res = game[1, 1] # получение значения центральной ячейки поля (возвращается число)
    # Если идет попытка присвоить новое значение в открытую клетку поля, то генерировать исключение:
    # raise ValueError('клетка уже занята')
    def __getitem__(self, item):
        # Также должны быть реализованы следующие полные срезы при обращении к клеткам игрового поля:
        # slice_1 = game[:, indx] # выбираются все элементы (кортеж) столбца с индексом indx
        if isinstance(item[0], slice) and isinstance(item[1], int):
            return tuple(_[item[1]].value for _ in self.pole)

        elif isinstance(item[0], int) and isinstance(item[1], slice):
            # slice_2 = game[indx, :] # выбираются все элементы (кортеж) строки с индексом indx
            return tuple(_.value for _ in self.pole[item[0]])

        if isinstance(item[0], int) and isinstance(item[1], int):
            if 0 <= item[0] < len(self.pole[0]) and 0 <= item[1] < len(self.pole[0]) and self.pole[item[0]][
                item[0]].is_free:
                return self.pole[item[0]][item[1]].value
            else:
                raise IndexError('неверный индекс клетки')


class Cell:
    """Клетка игрового поля"""

    def __init__(self):
        # Объекты класса Cell должны иметь следующие публичные локальные атрибуты:
        self.is_free = True  # True - если клетка свободна; False - в противном случае;
        # value - значение поля: 1 - крестик; 2 - нолик (по умолчанию 0).
        self.value = 0

    # Также с каждым объектом класса Cell должна работать функция:
    # - bool(cell) которая возвращает True, если клетка свободна (cell.is_free=True) и False в противном случае.
    def __bool__(self):
        return self.is_free is True


# end ваш код

# TEST-TASK___________________________________
from test3_8.test_3_8_8 import test_8

test_8(TicTacToe, Cell)

# END
