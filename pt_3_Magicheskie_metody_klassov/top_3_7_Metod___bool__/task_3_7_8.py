"""
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/2lnbu3n7Y_w

Большой подвиг 8.
Вы начинаете разрабатывать игру "Сапер". Для этого вам нужно уметь представлять и управлять игровым полем.
Будем полагать, что оно имеет размеры N x M клеток.
Каждая клетка будет представлена объектом класса Cell и содержать либо число мин вокруг этой клетки, либо саму мину.

Для начала в программе объявите класс GamePole, который будет создавать и управлять игровым полем.
Объект этого класса должен формироваться командой:
pole = GamePole(N, M, total_mines)
И, так как поле в игре одно, то нужно контролировать создание только одного объекта класса GamePole
(используйте паттерн Singleton, о котором мы с вами говорили, когда рассматривали магический метод __new__()).

Объект pole должен иметь локальный ПРИВАТНЫЙ атрибут:
__pole_cells - двумерный (вложенный) кортеж, размерами N x M элементов (N строк и M столбцов), состоящий из объектов класса Cell.
Для доступа к этой коллекции объявите в классе GamePole объект-свойство (PROPERTY):
- pole - только для чтения (получения) ссылки на коллекцию __pole_cells.

Далее, в самом классе GamePole объявите следующие методы:
- init_pole() - для инициализации начального состояния игрового поля (расставляет мины и делает все клетки закрытыми);
- open_cell(i, j) - открывает ячейку с индексами (i, j); нумерация индексов начинается с нуля; метод меняет значение атрибута __is_open объекта Cell в ячейке (i, j) на True;
- show_pole() - отображает игровое поле в консоли (как именно сделать - на ваше усмотрение, этот метод - домашнее задание).

Расстановку мин выполняйте случайным образом по игровому полю (для этого удобно воспользоваться функцией randint модуля random).
После расстановки всех total_mines мин, вычислите их количество вокруг остальных клеток (где нет мин).
Область охвата - соседние (прилегающие) клетки (8 штук).

В методе open_cell() необходимо проверять корректность индексов (i, j).
Если индексы указаны некорректно, то генерируется исключение командой:
- raise IndexError('некорректные индексы i, j клетки игрового поля')

Следующий класс Cell описывает состояние одной ячейки игрового поля. Объекты этого класса создаются командой:
cell = Cell()
При этом в самом объекте создаются следующие локальные приватные свойства:
- __is_mine - булево значение True/False; True - в клетке находится мина, False - мина отсутствует;
- __number - число мин вокруг клетки (целое число от 0 до 8);
- __is_open - флаг того, открыта клетка или закрыта: True - открыта; False - закрыта.
Для работы с этими приватными атрибутами объявите в классе Cell следующие ОБЪЕКТЫ-СВОЙСТВА с именами:
is_mine - для записи и чтения информации из атрибута __is_mine;
number - для записи и чтения информации из атрибута __number;
is_open - для записи и чтения информации из атрибута __is_open.
В этих свойствах необходимо выполнять проверку на корректность переданных значений (либо булево значение True/False, либо целое число от 0 до 8).
Если передаваемое значение некорректно, то генерировать исключение командой:
raise ValueError("недопустимое значение атрибута")
С объектами класса Cell должна работать функция:
bool(cell) - которая возвращает True, если клетка закрыта и False - если открыта.

______________
Пример использования классов (эти строчки в программе писать не нужно):
pole = GamePole(10, 20, 10)  # создается поле размерами 10x20 с общим числом мин 10
pole.init_pole()
if pole.pole[0][1]:
    pole.open_cell(0, 1)
if pole.pole[3][5]:
    pole.open_cell(3, 5)
pole.open_cell(30, 100)  # генерируется исключение IndexError
pole.show_pole()
P.S. В программе на экран выводить ничего не нужно, только объявить классы.
"""

from random import randint, randrange


# ваш код:
# здесь объявляйте классы
class GamePole:
    obj = None

    def __new__(cls, *args, **kwargs):
        if cls.obj is None:
            cls.obj = super().__new__(cls)
            return cls.obj
        else:
            return cls.obj

    # Должен иметь локальный ПРИВАТНЫЙ атрибут:
    # __pole_cells - двумерный (вложенный) кортеж, размерами N x M элементов (N строк и M столбцов), состоящий из объектов класса Cell.
    # Для доступа к этой коллекции объявите в классе GamePole объект-свойство (PROPERTY):
    # - pole - только для чтения (получения) ссылки на коллекцию __pole_cells.
    def __init__(self, n, m, total_mines):
        # N, M, total_mines
        self.n = n  # строк
        self.m = m  # столбцы
        self.total_mines = total_mines
        # __pole_cells состоящий из объектов класса Cell двумерный (вложенный) кортеж, размерами N x M элементов (N строк и M столбцов)
        self.__pole_cells = [[Cell() for k in range(self.m)] for i in range(self.n)]
        self.__list_mines = list()

    # _____ PROPERTY_____
    @property
    def pole(self):
        """ Геттер pole_cells"""
        return self.__pole_cells

    @property
    def list_mines(self):
        return self.__list_mines

    @list_mines.setter
    def list_mines(self, value):
        self.__list_mines = value

    # _____   END   _____

    # Далее, в самом классе GamePole объявите следующие методы:
    # - init_pole() - для инициализации начального состояния игрового поля (расставляет мины и делает все клетки закрытыми);
    # --------- Cell.__is_open = False  # - флаг того, открыта клетка или закрыта: True - открыта; False - закрыта.
    # _________ Cell.__is_mine = None  # - булево значение True/False; True - в клетке находится мина, False - мина отсутствует;
    # Расстановку мин выполняйте случайным образом по игровому полю (для этого удобно воспользоваться функцией randint модуля random).
    # После расстановки всех total_mines мин, вычислите их количество вокруг остальных клеток (где нет мин).
    # !!! Область охвата - соседние (прилегающие) клетки (8 штук).
    def init_pole(self):
        """для инициализации начального состояния игрового поля (расставляет мины и делает все клетки закрытыми)"""
        # Расстановку мин выполняйте случайным образом по игровому полю (для этого удобно воспользоваться функцией randint модуля random).
        # n - строки
        # m - столбцы
        count = 0  # счётчик расставленных мин
        while count < self.total_mines:  # работает пока мин меньше чем в переменной self.total_mines
            # random.randint(A, B) - случайное целое число N, A ≤ N ≤ B.
            i = randint(0, self.n - 1)
            k = randint(0, self.m - 1)
            if self.pole[i][k].is_mine is False:  # проверяем что в этом месте не стоит уже мина
                self.pole[i][k].is_mine = True  # если не стоит, то отмечаем что мина расположена тут
                # вносим активную (расставленную) мину во вспомогательный список
                self.list_mines.append(tuple((i, k)))
                count += 1  # увеличиваем счётчик расставленных мин
            else:
                continue

        # После расстановки всех total_mines мин, вычислите их количество вокруг остальных клеток (где нет мин).
        # !!! Область охвата - соседние (прилегающие) клетки (8 штук).
        ind = (-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)

        for i in self.list_mines:
            for k in ind:
                x, y = tuple(a + b for a, b in list(zip(i, k)))
                if 0 <= x < self.n and 0 <= y < self.m:
                    # делаем проверку если клетки пересекаются (рядом тоже есть мина) то суммируем
                    if self.pole[x][y].is_mine is not True:  # учитываем что в клетке может стоять мина -'*'
                        if self.pole[x][y].number == 0:  # если количество мин в переменной (0, None)
                            self.pole[x][y].number = 1  # увеличиваем на 1

                        elif int(self.pole[x][y].number) != 0:
                            self.pole[x][y].number = int(self.pole[x][y].number) + 1

        x = None
        y = None

    # - open_cell(i, j) - открывает ячейку с индексами (i, j); нумерация индексов начинается с нуля;
    # метод меняет значение атрибута __is_open объекта Cell в ячейке (i, j) на True;
    # _________ Cell.__is_open = False  # - флаг того, открыта клетка или закрыта: True - открыта; False - закрыта
    # В методе open_cell() необходимо проверять корректность индексов (i, j).
    # Если индексы указаны некорректно, то генерируется исключение командой:
    # - raise IndexError('некорректные индексы i, j клетки игрового поля')
    def open_cell(self, i, j):
        # В методе open_cell() необходимо проверять корректность индексов (i, j).
        # Если индексы указаны некорректно, то генерируется исключение командой:
        if 0 <= i <= self.n and 0 <= j <= self.m:
            # метод меняет значение атрибута __is_open объекта Cell в ячейке (i, j) на True;
            self.pole[i][j].is_open = True
        else:
            # Если индексы указаны некорректно, то генерируется исключение командой:
            raise IndexError('некорректные индексы i, j клетки игрового поля')

    # - show_pole() - отображает игровое поле в консоли (как именно сделать - на ваше усмотрение, этот метод - домашнее задание).
    def show_pole(self):
        for _ in self.pole:
            for i in _:
                if i.is_mine == True:
                    print('*', end=' ')
                else:
                    print(i.number, end=' ')
            print()


# Следующий класс Cell описывает состояние одной ячейки игрового поля.
# Объекты этого класса создаются командой: cell = Cell()
# При этом в самом объекте создаются следующие локальные ПРИВАТНЫЕ свойства:
# - __is_mine - булево значение True/False; True - в клетке находится мина, False - мина отсутствует;
# - __number - число мин вокруг клетки (целое число от 0 до 8);
# - __is_open - флаг того, открыта клетка или закрыта: True - открыта; False - закрыта.
# Для работы с этими ПРИВАТНЫМИ атрибутами объявите в классе Cell следующие ОБЪЕКТЫ-СВОЙСТВА с именами:
# is_mine - для записи и чтения информации из атрибута __is_mine;
# number - для записи и чтения информации из атрибута __number;
# is_open - для записи и чтения информации из атрибута __is_open.
# В этих свойствах необходимо выполнять проверку на корректность переданных значений (либо булево значение True/False, либо целое число от 0 до 8).
# Если передаваемое значение некорректно, то генерировать исключение командой:
# raise ValueError("недопустимое значение атрибута")
# С объектами класса Cell должна работать функция:
# bool(cell) - которая возвращает True, если клетка закрыта и False - если открыта.
class Cell:

    def __init__(self):
        self.__is_mine = False  # - булево значение True/False; True - в клетке находится мина, False - мина отсутствует;
        self.__number = 0  # - число мин вокруг клетки (целое число от 0 до 8);
        self.__is_open = False  # - флаг того, открыта клетка или закрыта: True - открыта; False - закрыта.

    # _____ PROPERTY_____
    @property
    def is_mine(self):
        """ Геттер is_mine"""
        return self.__is_mine

    @is_mine.setter
    def is_mine(self, value):
        """Сеттер is_mine"""
        if isinstance(value, bool):
            self.__is_mine = value
        else:
            raise ValueError("недопустимое значение атрибута")

    @property
    def number(self):
        """ Геттер number"""
        return self.__number

    @number.setter
    def number(self, value):
        """Сеттер is_mine"""
        if 0 <= int(value) <= 8:
            self.__number = value
        else:
            raise ValueError("недопустимое значение атрибута")

    @property
    def is_open(self):
        """ Геттер is_open"""
        return self.__is_open

    @is_open.setter
    def is_open(self, value):
        """Сеттер is_open"""
        if isinstance(value, bool):
            self.__is_open = value
        else:
            raise ValueError("недопустимое значение атрибута")

    # _____   END   _____

    # С объектами класса Cell должна работать функция:
    # bool(cell) - которая возвращает True, если клетка закрыта и False - если открыта.
    # self.__is_open = False  # - флаг того, открыта клетка или закрыта: True - открыта; False - закрыта.
    def __bool__(self):
        return False if self.is_open else True


# end ваш код

# TEST-TASK___________________________________
from test3_7.test_3_7_8 import test_8

test_8(GamePole, Cell)
# END
