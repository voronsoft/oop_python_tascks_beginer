"""
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/mg4b8nhVDKY

Подвиг 6.
Реализуйте односвязный список (не список Python, не использовать список Python для хранения объектов),
когда один объект ссылается на следующий и так по цепочке до последнего:

Для этого объявите в программе два класса:
- StackObj - для описания объектов односвязного списка;
- Stack - для управления односвязным списком.

Объекты класса StackObj предполагается создавать командой:
obj = StackObj(данные) -Здесь данные - это строка с некоторым содержимым.
Каждый объект класса StackObj должен иметь следующие локальные ПРИВАТНЫЕ атрибуты:
- __data - ссылка на строку с данными, указанными при создании объекта;
- __next - ссылка на следующий объект класса StackObj (при создании объекта принимает значение None).
Также в классе StackObj должны быть объявлены ОБЪЕКТЫ-СВОЙСТВА:
- next - для записи и считывания информации из локального ПРИВАТНОГО свойства __next;
- data - для записи и считывания информации из локального ПРИВАТНОГО свойства __data.
При записи необходимо реализовать проверку, что __next будет ссылаться на объект класса StackObj или значение None.
Если проверка не проходит, то __next остается без изменений.

Класс Stack предполагается использовать следующим образом:
st = Stack() # создание объекта односвязного списка
В объектах класса Stack должен быть локальный ПУБЛИЧНЫЙ атрибут:
 - top ссылка на первый добавленный объект односвязного списка (если список пуст, то top = None).
А в самом классе Stack следующие методы:
- push(self, obj) - добавление объекта класса StackObj в конец односвязного списка;
- pop(self) - извлечение последнего объекта с его удалением из односвязного списка;
- get_data(self) - получение списка из объектов односвязного списка
(список из строк локального атрибута __data каждого объекта в порядке их добавления, или пустой список, если объектов нет).

Пример использования классов Stack и StackObj (эти строчки в программе писать не нужно):
st = Stack()
st.push(StackObj("obj1"))
st.push(StackObj("obj2"))
st.push(StackObj("obj3"))
st.pop()
res = st.get_data()    # ['obj1', 'obj2']
P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.
"""


# Для этого объявите в программе два класса:
# - StackObj - для описания объектов односвязного списка;
# Объекты класса StackObj предполагается создавать командой:
# obj = StackObj(данные) -Здесь данные - это строка с некоторым содержимым.
class StackObj:
    # Каждый объект класса StackObj должен иметь следующие локальные ПРИВАТНЫЕ атрибуты:
    # - __data - ссылка на строку с данными, указанными при создании объекта;
    # - __next - ссылка на следующий объект класса StackObj (при создании объекта принимает значение None).
    def __init__(self, data):
        self.__data = data
        self.__next = None

    # Также в классе StackObj должны быть объявлены ОБЪЕКТЫ-СВОЙСТВА:
    # - next - для записи и считывания информации из локального ПРИВАТНОГО свойства __next;
    @property
    # считывание информации из локального ПРИВАТНОГО свойства __next
    def next(self):
        return self.__next

    @next.setter
    # запись информации из локального ПРИВАТНОГО свойства __next
    def next(self, value):
        self.__next = value

    @property
    # считывание информации из локального ПРИВАТНОГО свойства __data.
    def data(self):
        return self.__data

    @data.setter
    # запись информации из локального ПРИВАТНОГО свойства __data.
    # Если проверка не проходит, то __next остается без изменений.
    def data(self, value):
        if type(self.next) is StackObj or self.next is None:
            self.__data = value


#  Stack - для управления односвязным списком.
# Класс Stack предполагается использовать следующим образом:
# st = Stack() # создание объекта односвязного списка
class Stack:
    temp = None

    # В объектах класса Stack должен быть локальный ПУБЛИЧНЫЙ атрибут:
    # st.push(StackObj("obj1"))
    def __init__(self):
        #  - top ссылка на первый добавленный объект односвязного списка (если список пуст, то top = None).
        self.top = None

    # А в самом классе Stack следующие методы:
    # - push(self, obj) - добавление объекта класса StackObj в конец односвязного списка;
    # При записи необходимо реализовать проверку, что __next будет ссылаться на объект класса StackObj или значение None.
    # Если проверка не проходит, то __next остается без изменений.
    def push(self, _obj):
        if _obj.next is None or type(_obj) == StackObj:
            # запись в свойство-top адреса самого первого объекта.
            if self.top is None:
                self.top = _obj
                # запись во временную переменную
                self.temp = _obj

            elif self.top is not None:
                self.temp.next = _obj
                self.temp = _obj

    # - pop(self) - извлечение последнего объекта с его удалением из односвязного списка;
    def pop(self):
        if self.top.next is None:
            e = self.top
            self.top = None
            return e
        else:
            temp = self.top
            while temp.next is not None:
                _n = temp.next
                if _n.next is not None:
                    temp = temp.next
                else:
                    break
            temp.next = None

    # - get_data(self) - получение списка из объектов односвязного списка
    # (список из строк локального атрибута __data каждого объекта в порядке их добавления, или пустой список, если объектов нет).
    def get_data(self):
        lst = list()
        x = self.top
        while True:
            if self.top is not None:
                if x.next is not None:
                    lst.append(x.data)
                    x = x.next
                else:
                    lst.append(x.data)
                    break
            else:
                return lst
        return lst

# #  Проверка
# s = Stack()
# top = StackObj("obj_1")
# s.push(top)
# s.push(StackObj("obj_2"))
# s.push(StackObj("obj_3"))
# s.pop()
# 
# res = s.get_data()
# assert res == ["obj_1", "obj_2"], f"метод get_data вернул неверные данные: {res}"
# assert s.top == top, "атрибут top объекта класса Stack содержит неверное значение"
# 
# h = s.top
# while h:
#     res = h.data
#     h = h.next
# 
# s = Stack()
# top = StackObj("obj_1")
# s.push(top)
# s.pop()
# assert s.get_data() == [], f"метод get_data вернул неверные данные: {s.get_data()}"
# 
# n = 0
# h = s.top
# while h:
#     h = h.next
#     n += 1
# 
# assert n == 0, "при удалении всех объектов, стек-подобная структура оказалась не пустой"
# 
# s = Stack()
# top = StackObj("name_1")
# s.push(top)
# obj = s.pop()
# assert obj == top, "метод pop() должен возвращать удаляемый объект"
#
