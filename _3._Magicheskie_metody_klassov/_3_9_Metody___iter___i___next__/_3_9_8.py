"""
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/WrZ1TMwuvis
Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
Подвиг 8. Вы несколько раз уже делали стек-подобную структуру, когда объекты последовательно связаны между собой:
---- тут односвязный список ----
Доведем ее функционал до конца. Для этого, по-прежнему, нужно объявить классы:
Stack - для представления стека в целом;
StackObj - для представления отдельных объектов стека.

В классе Stack должны быть методы:
push_back(obj) - для добавления нового объекта obj в конец стека;
push_front(obj) - для добавления нового объекта obj в начало стека.
В каждом объекте класса Stack должен быть публичный атрибут:
top - ссылка на первый объект стека (при пустом стеке top = None).
Наконец, с объектами класса Stack должны выполняться следующие команды:
st = Stack()
st[indx] = value # замена прежних данных на новые по порядковому индексу (indx); отсчет начинается с нуля
data = st[indx]  # получение данных из объекта стека по индексу
n = len(st) # получение общего числа объектов стека
for obj in st: # перебор объектов стека (с начала и до конца)
    print(obj.data)  # отображение данных в консоль
При работе с индексами (indx), нужно проверять их корректность.
Должно быть целое число от 0 до N-1, где N - число объектов в стеке.
Иначе, генерировать исключение командой:
raise IndexError('неверный индекс')

Объекты класса StackObj создаются командой:
obj = StackObj(data)
где data - данные, хранящиеся в объекте стека (строка).
Также в каждом объекте класса StackObj должны быть публичные атрибуты:
data - ссылка на данные объекта;
next - ссылка на следующий объект стека (если его нет, то next = None).

P.S. В программе нужно объявить только классы. Выводить на экран ничего не нужно.
"""


# В классе Stack должны быть методы:
# push_back(obj) - для добавления нового объекта obj в конец стека;
# push_front(obj) - для добавления нового объекта obj в начало стека.
# В каждом объекте класса Stack должен быть публичный атрибут:
# top - ссылка на первый объект стека (при пустом стеке top = None).
# Наконец, с объектами класса Stack должны выполняться следующие команды:
# st = Stack()
# st[indx] = value # замена прежних данных на новые по порядковому индексу (indx); отсчет начинается с нуля
# data = st[indx]  # получение данных из объекта стека по индексу
# n = len(st) # получение общего числа объектов стека
# for obj in st: # перебор объектов стека (с начала и до конца)
#     print(obj.data)  # отображение данных в консоль
# При работе с индексами (indx), нужно проверять их корректность.
# Должно быть целое число от 0 до N-1, где N - число объектов в стеке.
# Иначе, генерировать исключение командой:
# raise IndexError('неверный индекс')
class Stack:
    """Представление стека в целом"""

    def __init__(self):
        self.top = None  # ссылка на первый объект стека (при пустом стеке top = None).
        self.lst = list()

    # В классе Stack должны быть методы:
    # push_back(obj) - для добавления нового объекта obj в конец стека;
    def push_back(self, obj):
        """Добавление нового объекта obj в КОНЕЦ стека"""
        if self.top is None:
            self.lst.append(obj)
            self.top = self.lst[0]
        else:
            # next последнего объекта меняем на добавляемый объект
            self.lst[-1].next = obj
            # теперь добавление нового объекта в конец списка
            self.lst.append(obj)

    # push_front(obj) - для добавления нового объекта obj в начало стека.
    def push_front(self, obj):
        """Добавление нового объекта obj в начало стека"""
        if self.top is None:
            self.lst.insert(0, obj)
            self.top = self.lst[0]
        else:
            # добавляем в lst новый объект (в начало списка)
            obj.next = self.lst[0]
            self.lst.insert(0, obj)  # list.insert(i, x) Вставляет на i-ый элемент значение x
            # изменяем self.top
            self.top = self.lst[0]

    # Наконец, с объектами класса Stack должны выполняться следующие команды:
    # При работе с индексами (indx), нужно проверять их корректность.
    # Должно быть целое число от 0 до N-1, где N - число объектов в стеке.
    # Иначе, генерировать исключение командой:
    # raise IndexError('неверный индекс')
    def veryfi_index(self, num):
        """Проверка индекса (попадает ли в диапазон односвязного списка"""
        if 0 <= num < len(self.lst):
            return True
        else:
            raise IndexError('неверный индекс')

    # st[indx] = value # замена прежних данных на новые по порядковому индексу (indx); отсчет начинается с 0
    def __setitem__(self, key, value):
        self.veryfi_index(key)
        self.lst[key].data = value

    # data = st[indx]  # получение данных из объекта стека по индексу
    def __getitem__(self, item):
        self.veryfi_index(item)
        return self.lst[item].data

    # n = len(st) # получение общего числа объектов стека
    def __len__(self):
        return len(self.lst)

    # for obj in st: # перебор объектов стека (с начала и до конца)
    #     print(obj.data)  # отображение данных в консоль
    def __iter__(self):
        for _ in self.lst:
            yield _


# Объекты класса StackObj создаются командой:
# obj = StackObj(data)
class StackObj:
    """Представление отдельных объектов стека"""

    def __init__(self, data):
        self.data = str(data)  # ссылка на данные объекта (строка)
        self.next = None  # ссылка на следующий объект стека (если его нет, то next = None).

# TEST
# st = Stack()
# st.push_back(StackObj("1"))
# st.push_front(StackObj("2"))
# #
# assert st[0] == "2" and st[1] == "1", "неверные значения данных из объектов стека, при обращении к ним по индексу"
# #
# st[0] = "0"
# assert st[0] == "0", "получено неверное значение из объекта стека, возможно, некорректно работает присваивание нового значения объекту стека"
# #
# for obj in st:
#     assert isinstance(obj, StackObj), "при переборе стека через цикл должны возвращаться объекты класса StackObj"
# #
# try:
#     a = st[3]
# except IndexError:
#     assert True
# else:
#     assert False, "не сгенерировалось исключение IndexError"
