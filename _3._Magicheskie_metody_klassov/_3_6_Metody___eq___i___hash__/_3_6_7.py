"""
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/rqCqhjtl6Lw
Подвиг 7. Объявите класс с именем DataBase (база данных - БД), объекты которого создаются командой:
db = DataBase(path)
где path - путь к файлу с данными БД (строка).
Также в классе DataBase нужно объявить следующие методы:
- write(self, record) - для добавления новой записи в БД, представленной объектом record;
- read(self, pk) - чтение записи из БД (возвращает объект Record) по ее уникальному идентификатору pk
(уникальное целое положительное число); запись ищется в значениях словаря (см. ниже)

Каждая запись БД должна описываться классом Record, а объекты этого класса создаваться командой:
record = Record(fio, descr, old)
где
- fio - ФИО некоторого человека (строка);
- descr - характеристика человека (строка);
- old - возраст человека (целое число).
В каждом объекте класса Record должны формироваться следующие локальные атрибуты:
pk - уникальный идентификатор записи (число: целое, положительное); формируется автоматически при создании каждого нового объекта;
fio - ФИО человека (строка);
descr - характеристика человека (строка);
old - возраст человека (целое число).

Реализовать для объектов класса Record вычисление хэша по атрибутам: fio и old (без учета регистра).
Если они одинаковы для разных записей, то и хэши должны получаться равными.
Также для объектов класса Record с одинаковыми хэшами оператор == должен выдавать значение True, а с разными хэшами - False.

Хранить записи в БД следует в виде словаря dict_db (атрибут объекта db класса DataBase),
ключами которого являются объекты класса Record, а значениями список из объектов с равными хэшами:
dict_db[rec1] = [rec1, rec2, ..., recN]
где rec1, rec2, ..., recN - объекты класса Record с одинаковыми хэшами.

Для наполнения БД прочитайте строки из входного потока с помощью команды:

lst_in = list(map(str.strip, sys.stdin.readlines()))
lst_in = ['Балакирев С.М.; программист; 33',
            'Кузнецов Н.И.; разведчик-нелегал; 35',
            'Суворов А.В.; полководец; 42',
            'Иванов И.И.; фигурант всех подобных списков; 26',
            'Балакирев С.М.; преподаватель; 33'
            ]
где каждая строка представлена в формате:

"ФИО; характеристика; возраст"

Например:

Балакирев С.М.; программист; 33
Кузнецов А.В.; разведчик-нелегал; 35
Суворов А.В.; полководец; 42
Иванов И.И.; фигурант всех подобных списков; 26
Балакирев С.М.; преподаватель; 37

Каждая строка должна быть представлена объектом класса Record и записана в БД db (в словарь db.dict_db).

P.S. На экран ничего выводить не нужно.

Sample Input:
Балакирев С.М.; программист; 33
Кузнецов Н.И.; разведчик-нелегал; 35
Суворов А.В.; полководец; 42
Иванов И.И.; фигурант всех подобных списков; 26
Балакирев С.М.; преподаватель; 33
Sample Output:
"""

import sys


# здесь продолжайте программу (используйте список строк lst_in)
class DataBase:
    """база данных - БД"""

    def __init__(self, path):
        # path - путь к файлу с данными БД (строка).
        self.path = str(path)

        # Хранить записи в БД следует в виде словаря dict_db (атрибут объекта db класса DataBase),
        # ключами которого являются объекты класса Record, а значениями список из объектов с равными хэшами:
        # dict_db[rec1] = [rec1, rec2, ..., recN]
        # где rec1, rec2, ..., recN - объекты класса Record с одинаковыми хэшами.
        self.dict_db = dict()

    # Также в классе DataBase нужно объявить следующие методы:
    # - write(self, record) - для добавления новой записи в БД, представленной объектом record;
    def write(self, record):
        cop = self.dict_db.copy()

        if len(self.dict_db) == 0:
            self.dict_db[record] = [record]
        else:
            for _ in cop:
                if _ == record:
                    self.dict_db[_].append(record)
                    break
                else:
                    self.dict_db[record] = [record]

    # - read(self, pk) - чтение записи из БД (возвращает объект Record) по ее уникальному идентификатору pk
    # (уникальное целое положительное число); запись ищется в значениях словаря (см. ниже)
    # r22 = db22345.read(r2.pk)
    def read(self, pk):
        for _i in self.dict_db.items():
            for k in _i[:]:
                if k.pk == pk:
                    return k


# Каждая запись БД должна описываться классом Record, а объекты этого класса создаваться командой:
# record = Record(fio, descr, old)
class Record:
    num = 0

    def __init__(self, fio, descr, old):
        self.pk = self.num_gen_unic()  # pk - уникальный идентификатор записи (число: целое, положительное); формируется автоматически при создании каждого нового объекта;
        self.fio = str(fio)  # - fio - ФИО некоторого человека (строка);
        self.descr = str(descr)  # - descr - характеристика человека (строка);
        self.old = int(old)  # - old - возраст человека (целое число).

    @classmethod
    def num_gen_unic(cls):
        cls.num += 1
        return cls.num

    # Реализовать для объектов класса Record вычисление хэша по атрибутам: fio и old (без учета регистра).
    # Если они одинаковы для разных записей, то и хэши должны получаться равными.
    def __hash__(self):
        return hash((self.fio.lower(), self.old))

    # Для объектов класса Record с одинаковыми хэшами оператор == должен быть True, с разными хэшами - False.
    def __eq__(self, other):  # ==
        return self.fio.lower() == other.fio.lower() and self.old == other.old


# Для наполнения БД прочитайте строки из входного потока с помощью команды:
# считывание списка из входного потока
lst_in = list(map(str.strip, sys.stdin.readlines()))  # список lst_in не менять!
# #######
db = DataBase('123')
for i in lst_in:
    text = i.split()
    text[-3] = text[-3].replace(';', '')
    item = Record(' '.join(text[0:-2]), str(text[-2]), int(text[-1]))
    # наполняем базу данных объектами
    db.write(item)

# # TEST
# db22345 = DataBase('123')
# r1 = Record('fio', 'descr', 10)
# r2 = Record('fio', 'descr', 10)
# assert r1.pk != r2.pk, "равные значения атрибута pk у разных объектов класса Record"
# #
# db22345.write(r2)
# r22 = db22345.read(r2.pk)
# assert r22.pk == r2.pk and r22.fio == r2.fio and r22.descr == r2.descr and r22.old == r2.old, "при операциях write и read прочитанный объект имеет неверные значения атрибутов"
# #
# assert len(db22345.dict_db) == 1, "неверное число объектов в словаре dict_db"
# #
# fio = lst_in[0].split(';')[0].strip()
# v = list(db.dict_db.values())
# if fio == "Балакирев С.М.":
#     assert len(v[0]) == 2 and len(v[1]) == 1 and len(v[2]) == 1 and len(v[3]) == 1, "неверно сформирован словарь dict_db"
# #
# if fio == "Гейтс Б.":
#     assert len(v[0]) == 2 and len(v[1]) == 2 and len(v[2]) == 1 and len(v[3]) == 1, "неверно сформирован словарь dict_db"
