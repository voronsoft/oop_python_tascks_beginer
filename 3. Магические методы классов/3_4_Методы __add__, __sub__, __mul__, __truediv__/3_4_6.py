"""
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/PY-E4OSh1gM
Теория по односвязным спискам (при необходимости): https://youtu.be/TrHAcHGIdgQ
Подвиг 6. Ранее, в одном из подвигов мы с вами создавали односвязный список с объектами класса StackObj (когда один объект ссылается на следующий и так далее):
Давайте снова создадим такую структуру данных. Для этого объявим два класса:
Stack - для управления односвязным списком в целом;
StackObj - для представления отдельных объектов в односвязным списком.
Объекты класса StackObj должны создаваться командой:
obj = StackObj(data)
где data - строка с некоторыми данными.
Каждый объект класса StackObj должен иметь локальные приватные атрибуты:
__data - ссылка на строку с переданными данными;
__next - ссылка на следующий объект односвязного списка (если следующего нет, то __next = None).

Объекты класса Stack создаются командой:
st = Stack()
и каждый из них должен содержать локальный атрибут:
top - ссылка на первый объект односвязного списка (если объектов нет, то top = None).
Также в классе Stack следует объявить следующие методы:
push_back(self, obj) - добавление объекта класса StackObj в конец односвязного списка;
pop_back(self) - удаление последнего объекта из односвязного списка.
Дополнительно нужно реализовать следующий функционал (в этих операциях копии односвязного списка создавать не нужно):
# добавление нового объекта класса StackObj в конец односвязного списка st
st = st + obj
st += obj

Добавление нескольких объектов в конец односвязного списка
st = st * ['data_1', 'data_2', ..., 'data_N']
st *= ['data_1', 'data_2', ..., 'data_N']
В последних двух строчках должны автоматически создаваться N объектов класса StackObj с данными,
взятыми из списка (каждый элемент списка для очередного добавляемого объекта).

P.S. В программе достаточно только объявить классы. На экран ничего выводить не нужно.
"""


class Stack:
    """- для управления односвязным списком в целом;"""

    def __init__(self):
        self.top = None  # top - ссылка на первый объект односвязного списка (если объектов нет, то top = None).
        self.lst = list()
        self.end_obj = None

    # Также в классе Stack следует объявить следующие методы:

    def push_back(self, obj):
        """push_back(self, obj) - добавление объекта класса StackObj в конец односвязного списка"""

        # если top=None обновляем ссылку
        if self.top is None:
            self.top = obj
            # обновляем ссылку __next у объекта(__next указывает на себя)
            self.top.next = obj
            # добавляем в список lst объект становится первым
            self.lst.append(obj)
            # end_obj указывает на последний объект
            self.end_obj = obj

        # если top указывает на себя, и объект 2‑й после top, меняем ссылку top.__next=obj
        elif self.top is not None and self.top.next == self.top:
            # меняем ссылку tpo.__next=obj
            self.top.next = obj
            # добавляем в список lst объект становится 2‑м
            self.lst.append(obj)
            # end_obj указывает на последний объект
            self.end_obj = obj

            # если obj новый список объектов
        elif isinstance(obj, Stack):
            # обновляем end_obj.next на первый объект из добавляемого списка
            self.end_obj.next = obj.top
            # теперь обновляем end_obj на последний объект из списка добавляемых объектов
            self.end_obj = obj.end_obj
            # соединяем списки lst + obj
            self.lst = self.lst + obj.lst
            return self

        # если добавляемый объект следующий после 2го и так далее
        else:
            # меняем ссылку __next у последнего объекта на ссылку добавляемого объекта
            self.end_obj.next = obj
            # end_obj обновляем на новый добавляемый объект
            self.end_obj = obj
            # теперь добавляем объект в список lst
            self.lst.append(obj)

    def pop_back(self):
        """pop_back(self) - удаление последнего объекта из односвязного списка."""
        pass

    # Дополнительно нужно реализовать следующий функционал (в этих операциях копии односвязного списка создавать не нужно):
    # # добавление нового объекта класса StackObj в конец односвязного списка st
    # st = st + obj
    def __add__(self, other):
        """Добавление нового объекта класса StackObj в конец односвязного списка st (создаем новый объект) st = st + obj"""
        self.push_back(other)
        return self

    def __iadd__(self, other):
        """Добавление объекта в конец односвязного списка к существующему списку (обновляем объект) st += obj"""
        #  добавляем новый объект
        self.push_back(other)
        return self

    # добавление нескольких объектов в конец односвязного списка
    # В последних двух строчках должны автоматически создаваться N объектов класса StackObj с данными,
    # взятыми из списка (каждый элемент списка для очередного добавляемого объекта).
    def __mul__(self, other):
        """добавление нескольких объектов st = st * ['data_1', 'data_2', ..., 'data_N']"""
        b = Stack()  # создаем объект список
        a = list(map(StackObj, other))  # создаем список объектов StackObj
        [b.push_back(_i) for _i in a]
        return self.push_back(b)

    def __imul__(self, other):
        """добавление нескольких объектов st *= ['data_1', 'data_2', ..., 'data_N']"""
        return self.__mul__(other)


class StackObj:
    """- для представления отдельных объектов в односвязным списком."""

    def __init__(self, data):  # где data - строка с некоторыми данными.
        self.__data = data
        self.__next = None  # ссылка на следующий объект списка (если следующего нет, то __next = None).

    # PROPERTY
    @property
    def next(self):
        """getter next"""
        return self.__next

    @next.setter
    def next(self, value):
        self.__next = value

    @property
    def data(self):
        """getter data"""
        return self.__data

    @data.setter
    def data(self, value):
        self.__data = value
    # END PROPERTY


# # TEST
# assert hasattr(Stack, 'pop_back'), "класс Stack должен иметь метод pop_back"
# #
# st = Stack()
# top = StackObj("1")
# st.push_back(top)
# assert st.top == top, "неверное значение атрибута top"
# #
# st = st + StackObj("2")
# st = st + StackObj("3")
# obj = StackObj("4")
# st += obj
# #
# st = st * ['data_1', 'data_2']
# st *= ['data_3', 'data_4']
# #
# d = ["1", "2", "3", "4", 'data_1', 'data_2', 'data_3', 'data_4']
# h = top
# i = 0
# while h:
#     assert h._StackObj__data == d[
#         i], "неверное значение атрибута __data, возможно, некорректно работают операторы + и *"
#     h = h._StackObj__next
#     i += 1
# #
# assert i == len(d), "неверное число объектов в стеке"
