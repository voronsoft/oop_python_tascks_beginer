"""
Видео-разбор подвига (решение смотреть только после своей попытки): https://youtu.be/5Y9qT5grunw
Большой подвиг 8.
Требуется реализовать программу по работе с решающими деревьями:
Здесь в каждом узле дерева делается проверка (задается вопрос).
#####################################################################################################
                                           TreeObj
            __________________________- Любит PYTHON___________________________________
              TreeObj 1 //                                              0 \\ TreeObj
            __Понимает ООП__________________________________- Любит "Кунг-фу Панда"____
             1 //          0 \\                                   1 //          0 \\
будет программистом______будет кодером_______________________не всё понятно_____безнадёжен

#####################################################################################################
Если проверка проходит, то осуществляется переход к следующему объекту по левой стрелке (с единицей),
а иначе - по правой стрелке (с нулем). И так до тех пор, пока не дойдем до одного из листа дерева (вершины без потомков).

В качестве входных данных используется вектор (список) с бинарными значениями: 1 - да, 0 - нет.
Каждый элемент этого списка соответствует своему вопросу (своей вершине дерева), например:
Индексы    0                1                   2
     Любит Python   Понимает ООП Любит    "Кунг-фу Панда
x = [      1,               0,                  1]
Далее, этот вектор применяется к решающему дереву, следующим образом.
Корневая вершина "Любит Python" с ней связан первый элемент вектора x и содержит значение 1,
следовательно, мы переходим по левой ветви.
Попадаем в вершину "Понимает ООП".
С ней связан второй элемент вектора x со значением 0,
следовательно, мы переходим по правой ветви и попадаем в вершину "будет кодером".
Так как эта вершина конечная (листовая), то получаем результат в виде строки "будет кодером".
По аналогии выполняется обработка вектора x с другими наборами значений 0 и 1.

Для реализации решающих деревьев в программе следует объявить два класса:
TreeObj - для описания вершин и листьев решающего дерева;
DecisionTree - для работы с решающим деревом в целом.

В классе DecisionTree должны быть реализованы (по крайне мере) два метода уровня класса (@classmethod):
- def predict(cls, root, x) - для построения прогноза (прохода по решающему дереву) для вектора x из корневого узла дерева root.
- def add_obj(cls, obj, node=None, left=True) - для добавления вершин в решающее дерево
(метод должен возвращать добавленную вершину - объект класса TreeObj);
В методе add_obj параметры имеют, следующие значения:
obj - ссылка на новый (добавляемый) объект решающего дерева (объект класса TreeObj);
node - ссылка на объект дерева, к которому присоединяется вершина obj;
left - флаг, определяющий ветвь дерева (объекта node), к которой присоединяется объект obj (True - к левой ветви; False - к правой).

В классе TreeObj следует объявить инициализатор:
- def __init__(self, indx, value=None): ...
- indx - проверяемый в вершине дерева индекс вектора x;
- value - значение, хранящееся в вершине
(принимает значение None для вершин, у которых есть потомки - промежуточных вершин).
При этом, в каждом создаваемом объекте класса TreeObj должны автоматически появляться следующие локальные атрибуты:
- indx - проверяемый индекс (целое число);
- value - значение с данными (строка);
Для работы с локальными ПРИВАТНЫМИ атрибутами __left и __right необходимо объявить ОБЪЕКТЫ-СВОЙСТВА с именами left и right.
- __left - ссылка на следующий объект дерева по левой ветви (изначально None);
- __right - ссылка на следующий объект дерева по правой ветви (изначально None).

Эти классы в дальнейшем предполагается использовать следующим образом (эти строчки в программе не писать):
root = DecisionTree.add_obj(TreeObj(0))
v_11 = DecisionTree.add_obj(TreeObj(1), root)
v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
DecisionTree.add_obj(TreeObj(-1, "будет программистом"), v_11)
DecisionTree.add_obj(TreeObj(-1, "будет кодером"), v_11, False)
DecisionTree.add_obj(TreeObj(-1, "не все потеряно"), v_12)
DecisionTree.add_obj(TreeObj(-1, "безнадежен"), v_12, False)
x = [1, 1, 0]
res = DecisionTree.predict(root, x) # будет программистом
P.S. В программе требуется объявить только классы. На экран ничего выводить не нужно.
"""


# Для реализации решающих деревьев в программе следует объявить два класса:
# TreeObj - для описания вершин и листьев решающего дерева;
class TreeObj:
    # В классе TreeObj следует объявить инициализатор:
    # - def __init__(self, indx, value=None): ...
    # где indx - проверяемый в вершине дерева индекс вектора x;
    # где value - значение, хранящееся в вершине (принимает значение None для вершин, у которых есть потомки - промежуточных вершин).
    # root = TreeObj(0)
    # x1 = TreeObj(1), root
    # x2 = TreeObj(2), root, False
    def __init__(self, indx, value=None):
        # При этом, в каждом создаваемом объекте класса TreeObj должны автоматически появляться следующие локальные атрибуты:
        # - indx - проверяемый индекс (целое число);
        if type(indx) is int:
            self.indx = indx
        else:
            self.indx = None

        # - value - значение, хранящееся в вершине
        # (принимает значение None для вершин, у которых есть потомки - промежуточных вершин).
        self.value = value

        # с каким  объектом соединён
        self.connected = None

        # - __left - ссылка на следующий объект дерева по левой ветви (изначально None);
        self.__left = None

        # - __right - ссылка на следующий объект дерева по правой ветви (изначально None).
        self.__right = None

    # ############################# @property ##############################
    # Для работы с локальными приватным атрибутом __left необходимо объявить ОБЪЕКТ-СВОЙСТВО с именем left.
    @property
    def left(self):
        return self.__left

    @left.setter
    def left(self, value):
        self.__left = value

    # ----------------------------

    # Для работы с локальным приватным атрибутам __right необходимо объявить ОБЪЕКТ-СВОЙСТВО с именем right.
    @property
    def right(self):
        return self.__right

    @right.setter
    def right(self, value):
        self.__right = value
    # ############################# end ##############################


# DecisionTree - для работы с решающим деревом в целом.
class DecisionTree:

    # В классе DecisionTree должны быть реализованы (по крайне мере) два метода уровня класса (@classmethod):
    # - def predict(cls, root, x) - для построения прогноза (прохода по решающему дереву) для вектора x из корневого узла дерева root.
    @classmethod
    def predict(cls, root, x):
        temp = root
        for ind, vol in enumerate(x):  # 0 1 2
            if temp.indx == ind and vol == 1:
                if temp.left.value is not None:
                    return temp.left.value
                else:
                    temp = temp.left

            elif temp.indx == ind and vol == 0:
                if temp.right.value is not None:
                    return temp.right.value
                else:
                    temp = temp.right

    # - def add_obj(cls, obj, node=None, left=True) - для добавления вершин в решающее дерево
    # (метод должен возвращать добавленную вершину - объект класса TreeObj);
    # В методе add_obj параметры имеют, следующие значения:
    # obj - ссылка на новый (добавляемый) объект решающего дерева (объект класса TreeObj);
    # node - ссылка на объект дерева, к которому присоединяется вершина obj;
    # left - флаг, определяющий ветвь дерева (объекта node), к которой присоединяется объект obj (True - к левой ветви; False - к правой).
    @classmethod
    def add_obj(cls, obj, node=None, left=True):
        if node is not None:
            if left:
                node.left = obj
            else:
                node.right = obj
        return obj


# TEST-TASK___________________________________
assert hasattr(DecisionTree, 'add_obj') and hasattr(DecisionTree, 'predict'), \
    "в классе DecisionTree должны быть методы add_obj и predict"

assert type(TreeObj.left) == property and type(TreeObj.right) == property, \
    "в классе TreeObj должны быть объекты-свойства left и right"

root = DecisionTree.add_obj(TreeObj(0))
v_11 = DecisionTree.add_obj(TreeObj(1), root)
v_12 = DecisionTree.add_obj(TreeObj(2), root, False)
DecisionTree.add_obj(TreeObj(-1, "программист"), v_11)
DecisionTree.add_obj(TreeObj(-1, "кодер"), v_11, False)
DecisionTree.add_obj(TreeObj(-1, "посмотрим"), v_12)
DecisionTree.add_obj(TreeObj(-1, "нет"), v_12, False)

assert DecisionTree.predict(root, [1, 1, 0]) == 'программист', "неверный вывод решающего дерева"
assert DecisionTree.predict(root, [0, 1, 0]) == 'нет', "неверный вывод решающего дерева"
assert DecisionTree.predict(root, [0, 1, 1]) == 'посмотрим', "неверный вывод решающего дерева"
print("Правильный ответ !!")
